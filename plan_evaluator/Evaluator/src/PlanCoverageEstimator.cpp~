/*
 * PlanCoverageEstimator.cpp
 *
 *  Created on: Apr 20, 2015
 *      Author: kaiolae
 */

#include "PlanCoverageEstimator.h"

#include <boost/exception/diagnostic_information.hpp>
#include <stddef.h>
#include <algorithm>
#include <assert.h>
#include <iostream>
#include <iterator>
#include <osg/BoundingSphere>
#include <osg/Camera>
#include <osg/LightModel>
#include <osg/Matrixd>
#include <osg/MixinVector>
#include <osg/Node>
#include <osg/Shape>
#include <osg/ShapeDrawable>
#include <osg/StateSet>
#include <osg/Vec3d>
#include <osg/Vec3f>
#include <osg/Vec4>
#include <osg/Vec4f>
#include <osg/View>
#include <osgDB/ReadFile>
#include <osgText/Text>
#include <osgText/TextBase>
#include <osgViewer/Viewer>
#include <sstream>
#include <stdexcept>
#include <utility>

#include "../../Common/src/CameraEstimator.h"
#include "../../Common/src/HelperMethods.h"
#include "../../Common/src/KeyboardInputHandler.h"
#include "../../Common/src/OsgHelpers.h"
#include "PlanEnergyEvaluator.h"
#include "PlanInterpreterBoxOrder.h"
#include "PlanInterpreterMovementCommands.h"
#include "../../Common/src/SceneKeeper.h"
#include "../../Common/src/Constants.h"

using namespace inspection_planning_common;
namespace evolutionary_inspection_plan_evaluation {

//TODO: Checking if the matrix was ever set is also a good idea.
///Used from the Python interface.
std::vector<std::vector<double> > viewMatrixSelector(
		std::string sceneFileName) {
	return inspection_planning_common::viewMatrixSelector(sceneFileName);
}

void PlanCoverageEstimator::storePlanImage(const std::vector<std::vector<double> >& plan, const std::vector<std::vector<double> >& viewMatrix, std::string& storagePath) {
	osg::ref_ptr<osg::Group> drawable = new osg::Group; //The drawable to plot inside our plan
	evaluatePlan(plan, false, image, -1, drawable);
	osg::Matrixd vm = convertNestedVectorToMatrix(viewMatrix);
	storeViewToFile(drawable, vm, storagePath);
}

//TODO: Because of this, it may make sense to connect subtours: It gives us fewer combinations of tours to consider.
int PlanCoverageEstimator::initializeMandatoryLoops(const std::vector<std::string>& mandatoryLoopsFiles) {
	PlanInterpreterBoxOrder* interpreter;
	if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
		interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	} else {
		throw std::domain_error(
				"ERROR! Mandatory loops are only supported for a  'box-order' representation of plans");
	}

	std::unique_ptr<CompleteCoverageSegments> loadedSegments(new CompleteCoverageSegments());
	for(auto loopFilesIt = mandatoryLoopsFiles.begin(); loopFilesIt!=mandatoryLoopsFiles.end(); loopFilesIt++){
		try{
			loadFromFile(*loopFilesIt, *loadedSegments);
		} catch (boost::archive::archive_exception &err){
			std::cerr << "Loading plan segment from file failed. Incompatible file was: " << *loopFilesIt << ". BOOST's error info follows:" << std::endl;
			// Output some debug information.
			std::cerr << boost::diagnostic_information(err) << std::endl;
			throw;
		}
	}

	int numSegments = loadedSegments->getNumSegments();
	interpreter->setMandatorySegments(std::move(loadedSegments));
	return numSegments;
}

//TODO: There is potential for additional memoization by memoizing each mandatory loop, and reusing the result wherever that loop is inserted in the plan.
//However, that will requre major restructuring, and only lead to a small improvement, so I'm skipping it.
boost::dynamic_bitset<> PlanCoverageEstimator::evaluateMemoisedPlan(const std::vector<std::vector<double> >& plan){

	PlanInterpreterBoxOrder* interpreter;
	if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
		interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	} else {
		throw std::domain_error(
				"ERROR! Memoization is only supported for a  'box-order' representation of plans");
	}

	osg::Vec3d previousLocation;
	std::string previousPlanPartName = "None";
	if (startLocation != nullptr) {
		previousPlanPartName = "start";
		previousLocation = osg::Vec3d((*startLocation)[0], (*startLocation)[1],
				(*startLocation)[2]);
	}

	boost::dynamic_bitset<> observedColors(sceneKeeper->getTriangleCount());
	int memoizedCount = 0;
	int notmemoizedCount = 0;
	for (size_t i = 0; i < plan.size(); i++) {
		//Each part of a plan is a vector of doubles - representing a single viewpoint. The first element of the vector is the position of that viewpoint.
		std::vector<double> currentPlanPart = plan[i];
		if (i != 0) {
			previousPlanPartName = vectorToString(plan[i - 1], 1);
		}
		std::string currentPlanPartName = vectorToString(currentPlanPart,
				currentPlanPart.size());
		std::string memoizationIndex = previousPlanPartName + "-"
				+ currentPlanPartName; //The string we use to store and look up the current edge.

		//std::cout << "Evaluating "<< memoizationIndex << std::endl;

		boost::dynamic_bitset<> currentlyObservedColors(sceneKeeper->getTriangleCount());
		if (memoisedEdgesBitset->find(memoizationIndex)	== memoisedEdgesBitset->end()) {
			//TODO: Get an overview over exactly how this decodedpositions is filled.
			notmemoizedCount+=1;
			//Element not memoized. Calculating manually.
			osg::ref_ptr<osg::Vec3dArray> decodedPositions = new osg::Vec3dArray;
			osg::ref_ptr<osg::Vec3dArray> decodedAngles = new osg::Vec3dArray;
			if (previousPlanPartName != "start"	&& previousPlanPartName != "None") {
				previousLocation = interpreter->getPositionFromGene(plan, i - 1);
			}
			if (previousPlanPartName == "None") {
				//In the special case that this is the first point, we have no previous point.
				//This will normally result in no decoded edges (which will simply result in no observed primitives),
				//but in the case that the plan starts with a loop, we will have edges also in this first part of the plan.
				interpreter->InterpretOnePlanPoint(nullptr, currentPlanPart, *decodedPositions, *decodedAngles);

			} else {
				decodedPositions->push_back(previousLocation); //Move starts at previous location
				interpreter->InterpretOnePlanPoint(&previousLocation,currentPlanPart, *decodedPositions, *decodedAngles);
			}
			if (decodedPositions->size() < 2) {
				//The decoding only gave us a single waypoint. No edge to traverse. This should only happen when decoding the first point
				assert(i == 0);
				continue;
			}
			//Fetched the next viewpoints and angles (often this will just be one viewpoint). Now, recording and storing their coverage.
			for (size_t edgeNr = 0; edgeNr < decodedAngles->size(); edgeNr++) {
				//Iterates over all the edges we just decoded (usually just one, unless we decoded a complete loop).
				osg::Vec3d previousNode = decodedPositions->at(edgeNr);
				osg::Vec3d nextNode = decodedPositions->at(edgeNr + 1);
				osg::Vec3d angle = decodedAngles->at(edgeNr);
				cam_estimator->GetColorsDuringTraversal(previousNode, nextNode,
						angle, coloredScene, currentlyObservedColors);
				observedColors |= currentlyObservedColors; //bitwise OR
				(*memoisedEdgesBitset)[previousPlanPartName + "-"
						+ currentPlanPartName] = currentlyObservedColors;
			}

		} else {
			memoizedCount+=1;
			//Element memoized. Fetching values.
			boost::dynamic_bitset<> memoizedResult =
					memoisedEdgesBitset->at(memoizationIndex);
			observedColors |= memoizedResult;
		}

	}

	return observedColors;

}

std::vector<double> PlanCoverageEstimator::evaluateEmptyPlan() const{
	//Immediately giving the default score to empty plans can speed evaluation up.
	double objectiveScores[] = { 1.0, 0 }; //The score for an empty plan. No coverage, no energy spent.
	std::vector<double> scoreVector(objectiveScores,
			objectiveScores + sizeof(objectiveScores) / sizeof(double));
	return scoreVector;
}

boost::dynamic_bitset<> PlanCoverageEstimator::evaluatePlanInternal(const std::vector<std::vector<double> >& plan,osg::ref_ptr<osg::Geode> geode) const{

	osg::ref_ptr<osg::Vec3dArray> plannedPositions = new osg::Vec3dArray(); //All points we will visit
	osg::ref_ptr<osg::Vec3dArray> plannedAngles = new osg::Vec3dArray(); //The angle the AUV will point towards in those positions.
	//TODO: Remove textureRoot?
	osg::ref_ptr<osg::Group> textureRoot(new osg::Group); //For plotting only the texture showing what the simulated camera sees.

	planInterpreter->InterpretPlan(plan, *plannedPositions, *plannedAngles);
	osg::Vec3d currentLocation = (*plannedPositions)[0];

	boost::dynamic_bitset<> observedColors(sceneKeeper->getTriangleCount());
	//Going through each edge, calculating it's coverage.
	for (unsigned int i = 0; i < plannedAngles->size(); i++) {
		osg::Vec3d nextLocation = (*plannedPositions)[i + 1]; //We have one more position than angles, as positions refer to nodes, and angles to edges.
		osg::Vec3d sensorHeading = (*plannedAngles)[i];
		cam_estimator->GetColorsDuringTraversal(currentLocation, nextLocation,
				sensorHeading, coloredScene, observedColors, textureRoot);

		currentLocation = nextLocation;
	}

	if (geode != nullptr) {

		drawTrajectory(plannedPositions, plannedAngles, *geode); //Drawing the AUV's path to the geode.
	}
	return observedColors;
}

PlanCoverageEstimator::~PlanCoverageEstimator() {
	//delete planInterpreter;
	delete sceneKeeper;
	delete energyEvaluator;
	delete cam_estimator;
}

//Only valid if we have a "Box-Order" interpretation of our plan.
int PlanCoverageEstimator::getNumberOfBoxes() const{

	PlanInterpreterBoxOrder* interpreter =
			dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	assert(interpreter != nullptr);
	return interpreter->getNumberOfBoxes();
}

PlanCoverageEstimator::PlanCoverageEstimator(const std::string& sceneFileName,
		const std::vector<double>& sensorSpecs, const std::string& interpretationType,
		bool postProcessing/*=false*/, const std::vector<double>* startLocation/*=nullptr*/, bool planLoopsAround /*= false*/,
		bool printerFriendly/*=true*/,
		const std::vector<std::string>& mandatoryPlanPartsFiles/* = std::vector<std::string>()*/)
	:startLocation(startLocation),
	 planLoopsAround(planLoopsAround){
	std::cout << "Loading scene" << std::endl;
	this->printerFriendly = printerFriendly;
	sceneKeeper = new SceneKeeper(sceneFileName);
	sceneKeeper->countTriangles();

	memoisedEdgesBitset = new std::map<std::string, boost::dynamic_bitset<> >;
	coloredScene = sceneKeeper->colorEachTriangleDifferently();

	cam_estimator = new CameraEstimator(sensorSpecs);

	bool usingMaxEnergy = true;
	if (interpretationType == "MovementCommands") { //TODO: No longer supporting "movementcommands"
		planInterpreter = new PlanInterpreterMovementCommands(startLocation);
		usingMaxEnergy = false;
	}
	else {
		assert (interpretationType == "BoxOrder"|| interpretationType == "DualGenotype"	|| interpretationType == "InterleavedGenotype");
		this->boxes = new osg::Vec3dArray();
		PlanInterpreterBoxOrder* interpreter = new PlanInterpreterBoxOrder(*sceneKeeper, boxes, *cam_estimator, coloredScene, startLocation, postProcessing);
		planInterpreter = interpreter;
		if (!postProcessing) {
			usingMaxEnergy = true;
			interpreter->ProduceSimpleGalceranPlans();
		} else {
			//In post-processing runs, we do not estimate the max energy, to save time.
			usingMaxEnergy = false;
			interpreter->setPostProcessing(true);
		}
	}

	if(mandatoryPlanPartsFiles.size()!=0){
		initializeMandatoryLoops(mandatoryPlanPartsFiles);
	}
	energyEvaluator = new PlanEnergyEvaluator(usingMaxEnergy, this,	planInterpreter, *sceneKeeper);
	std::cout << "Constructor done " << std::endl;

}

//TODO This method will have problems with the plan encoding curwith mandatory parts.
std::vector<std::vector<std::vector<double> > > PlanCoverageEstimator::produceNeigbors(
		const std::vector<std::vector<double> >& currentPlan,
		double localSearchLimit) const{

	PlanInterpreterBoxOrder* interpreter;
	if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
		interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	} else {
		throw std::domain_error(
				"ERROR! Local search is only supported for a  'box-order' representation of plans");
	}
	std::vector<std::vector<std::vector<double> > > allNeighbors;

	int counter = 0;
	//This was some code I used to insert neighboring boxes, and delete boxes from plan.
	for (std::vector<std::vector<double> >::const_iterator planIterator =
			currentPlan.begin(); planIterator != currentPlan.end();
			planIterator++) {
		std::vector<double> currentPlanStep = *planIterator;
		int currentBoxId = (int) (currentPlanStep[0] + 0.5); //Rounding to nearest int.
		//TODO: I used to have insertion and deletion as part of neighbor search here. I removed it, but saved the code in old_code.
		double max_waypoint_move = localSearchLimit
				* sceneKeeper->getSceneDiagonal();

		//Testing swapping each plan element with each other element. Can reduce complexity somewhat by selecting more
		//intelligently here, probably.
		for (int swapInElement = 0; swapInElement < getNumberOfBoxes();
				swapInElement++) {
			//Only accepting the swap if the new waypoint is close enough to the old waypoint. This is to reduce the size of the local
			//search, and rests upon the assumption that the current plan is already "quite good" - so large changes are not likely to improve it.
			if (currentBoxId != swapInElement
					&& (interpreter->getBoxPosition(swapInElement)
							- interpreter->getBoxPosition(currentBoxId)).length()
							< max_waypoint_move) {
				std::vector<std::vector<double> > newIndividual = currentPlan;
				newIndividual[counter][0] = swapInElement;
				//Consecutive duplicated points produce an error in energy calculations. Remove them.
				removeConsecutiveDuplicatedPoints(newIndividual);
				allNeighbors.push_back(newIndividual);
			}
		}

		counter += 1;
	}
	std::cout << "Size of AllNeighbors is " << allNeighbors.size() << std::endl;

	return allNeighbors;
}

//Finds and returns the best plan in the local neighborhood of the input plan
//TODO: Only implementing this for the Box-Order representation, as I don't know if the local search makes sense for the
//Other representation.
//TODO: Great idea: How about using the following as objective for the local search: (areaCovered/energySpent) - then, I'm actually maximizing the
//efficiency of the plan - but I still have to use some scaling weights, right??
std::vector<std::vector<double> > PlanCoverageEstimator::LocalSearch (
		const std::vector<std::vector<double> >& plan, double localSearchLimit,
		int startNeighbor) {			//, std::vector<double>* pseudoweights){

	std::cout << "Local search around " << plan << std::endl;
	if (plan.size() == 0) {
		return plan; //Degenerate plans are not optimized.
	}

	std::vector<double> originalScore = evaluatePlan(plan, true, nothing);
	std::cout << "Original plan had score " << originalScore << std::endl;

	//All neighbors and their scores.
	std::vector<std::vector<std::vector<double> > > neighbors = produceNeigbors(
			plan, localSearchLimit);
	std::vector<std::vector<double> > neighborObjectiveValues;
	std::cout << "Produced " << neighbors.size() << " neighbors" << std::endl;

	//Starting search around where we left off at previous recursion step makes search more efficient.
	//Not starting exactly where the counter stopped, because the current set of neighbors may be slightly different than the previous.
	unsigned int searchOffset = std::max(startNeighbor - 50, 0);
	if (searchOffset >= neighbors.size()) {
		searchOffset = 0;
	}

	std::cout << "Search offset is " << searchOffset << std::endl;
	//Iterating over list starting at searchOffset, looping around.
	for (unsigned int counter = 0; counter < neighbors.size(); counter++) {
		int neighborIndex = (searchOffset + counter) % neighbors.size();
		if (neighborIndex % 100 == 0) {
			std::cout << "Analyzing neighbors: " << neighborIndex << std::endl;
		}
		std::vector<std::vector<double> > currentNeighbor =
				neighbors[neighborIndex];
		//Sending the original score to the evaluator speeds this up, by skipping all individuals with higher energy usage immediately.
		//Most plans are discarded without checking coverage, since they are much more energy demanding than the optimized original.
		std::vector<double> neighborObjectiveScores = evaluatePlan(
				currentNeighbor, true, nothing, originalScore[1]);
		//Checking for dominance - requiring that no objective is worse, and at least one is better.
		if (vectorDominates(neighborObjectiveScores, originalScore)) {
			std::cout
					<< "Found better solution! Recursive call to search around this new solution. "
					<< neighborObjectiveScores << std::endl;
			return LocalSearch(currentNeighbor, localSearchLimit, neighborIndex);
		}

	}
	//No better neighbor found in current recursive call. That means the original individual is the best in its neighborhood.
	return plan;
}


	//This way of passing the how_to_plot arguement is not very elegant (I would prefer an enum).
	//However, this method needs to be callable from Python - therefore, passing as a string works better.
std::vector<double> PlanCoverageEstimator::evaluatePlan(
			const std::vector<std::vector<double> > &plan, bool memoization,
			plotting_style how_to_plot, double strictEnergyLimit/*=-1*/,
			osg::ref_ptr<osg::Group> returnedDrawable/*=nullptr*/) {

	std::cout << "Received plot style " << how_to_plot << std::endl;
	if(how_to_plot==image && returnedDrawable== nullptr){
		throw std::logic_error("ERROR! Asked to plot image, but not given an OSG-drawable to plot to.");
	}

	//std::cout << "Evaluating plan: " << plan << std::endl;
	if (plan.size() == 0) {
		return evaluateEmptyPlan();
	}

	//Making a copy of the plan that we can modify - so we are sure never to mess with the genotype.
	std::vector<std::vector<double> > planCopy = plan;
	//If we want to enforce looping, we simply reinsert the first waypoint in the end.
	//TODO: This is not perfect for plans with a user-defined start-position, but it will usually not be too bad either.
	if(planLoopsAround){
		planCopy.push_back(plan[0]);
	}

	double energyUsed;
	//An initial check if I'm using too much energy.
	if (!energyEvaluator->energyWithinBounds(planCopy, energyUsed,
			strictEnergyLimit)) {
		//std::cout << "Current plan: " << plan << std::endl;
		double objectiveScores[] = { 1, energyUsed }; //For both objectives: 0 is best score.
		std::vector<double> scoreVector(objectiveScores,
				objectiveScores + sizeof(objectiveScores) / sizeof(double));
		return scoreVector;
	}

	//TODO: try to just send the geode, and keep the root here.
	osg::ref_ptr<osg::Group> root = nullptr; //For plotting
	osg::ref_ptr<osg::Geode> geode = nullptr; //For plotting
	osg::ref_ptr<osg::Group> textureRoot = nullptr; //For plotting only the texture showing what the simulated camera sees.
	if (how_to_plot!=nothing) {
		root = new osg::Group;
		geode = new osg::Geode();
		textureRoot = new osg::Group;
		if (how_to_plot!=image) { //Only if we want to plot to screen, rather than store an image of the scene

			PlanInterpreterBoxOrder* interpreter;
			if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
				interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
			} else {
				throw std::domain_error(
						"ERROR! Local search is only supported for a  'box-order' representation of plans");
			}
			//Marking the mandatory waypoints with spheres.
			int counter = 0;
			std::cout << "Boxes size: " << boxes->size() << std::endl;
			for(auto planPart: planCopy){
				double id = planPart[0];
				std::cout << "planPart: " << id << std::endl;
				if(id>=boxes->size()){

					osg::Vec3d pos = interpreter->getPositionFromGene(planCopy,counter);
					osg::Sphere *wpSphere = new osg::Sphere(pos, 0.25);
					osg::ShapeDrawable *sphereDrawable = new osg::ShapeDrawable(
							wpSphere);
					sphereDrawable->setColor(osg::Vec4(0.5f, 0.5f, 0.5f, 1.0f));
					geode->addDrawable(sphereDrawable);
				}
				counter+=1;
			}
			//Adding a large sphere to show the scene center
			//osg::Sphere *wpSphere = new osg::Sphere(sceneKeeper->getSceneCenter(), 5.0);
			//osg::ShapeDrawable *sphereDrawable = new osg::ShapeDrawable(wpSphere);
			//sphereDrawable->setColor(osg::Vec4(1.0f, 0.2f, 0.2f, 1.0f));
			//geode->addDrawable(sphereDrawable);

			counter = 0;
			//TODO: insert these waypoint-indicator balls again, but make sure they don't interfere with viewpoints.
			for (osg::Vec3dArray::iterator boxIt = boxes->begin();
					boxIt != boxes->end(); boxIt++) {
				osg::ref_ptr<osgText::Text> textLabel = new osgText::Text();
				//geode->addDrawable(textLabel);
				osg::Sphere *wpSphere = new osg::Sphere(*boxIt, 0.25);
				osg::ShapeDrawable *sphereDrawable = new osg::ShapeDrawable(
						wpSphere);
				sphereDrawable->setColor(osg::Vec4(0.5f, 0.5f, 0.5f, 1.0f));
				//geode->addDrawable(sphereDrawable);
				std::ostringstream text;
				text << counter;
				textLabel->setText(text.str());
				textLabel->setCharacterSize(0.2);
				textLabel->setAxisAlignment(osgText::Text::XZ_PLANE);
				textLabel->setPosition(*boxIt);
				counter += 1;
			}

		}
	}

	//We use one of these to measure coverage.
	boost::dynamic_bitset<> observedColors; ///<Will contains zeros for all colors that have not been observed by the camera, and one for those that have.
	std::set<int> coveredPrimitives;

	if (memoization) {
		observedColors = evaluateMemoisedPlan(planCopy);
	} else {
		observedColors = evaluatePlanInternal(planCopy, geode);
	}

	double coverageScore;
	if (how_to_plot!=nothing) {
		coverageScore = sceneKeeper->calculateCoverage(observedColors, geode,
				printerFriendly);

	} else {
		coverageScore = sceneKeeper->calculateCoverage(observedColors);
	}
	double objectiveScores[] = { coverageScore, energyUsed }; //For both objectives: 0 is best score.

	//TODO: Testing code. Delete.


	//----Test code done--//
	if (how_to_plot==normal) {

		std::cout << "No drawable given. Running viewer" << std::endl;
		osgViewer::Viewer viewer;
		osg::ref_ptr<osg::Group> fullScene = new osg::Group;

		//This code makes sure surfaces are lit from both sides - fixing any erroneously flipped normals.
		//osg::ref_ptr<osg::LightModel> lightModel = new osg::LightModel;
		//lightModel->setTwoSided(true);
		//fullScene->getOrCreateStateSet()->setAttributeAndModes(
		//		lightModel.get());

		//fullScene->addChild(textureRoot);
		//fullScene->addChild(root);
		fullScene->addChild(geode);
		viewer.setSceneData(fullScene.get());
		viewer.run();
	} else if(how_to_plot==image) {
		returnedDrawable->addChild(geode);
	}
	else if(how_to_plot==circulating){
		run_rotating_camera(geode);
	}

	std::vector<double> scoreVector(objectiveScores,
			objectiveScores + sizeof(objectiveScores) / sizeof(double));

	//std::cout << "Plan score was: " << scoreVector << std::endl;
	return scoreVector;

}

bool PlanCoverageEstimator::edgeConnectsMandatoryPart(const std::string& edgeName){
	//Edgename is a descriptor of the edge on the form "123-212" where 123 and 212 are valid waypoint IDs.
	std::vector<std::string> waypointsInEdge = splitString(edgeName,'-');
	size_t startWp = 0;
	size_t endWp = 0;
	try{
		if(waypointsInEdge.front() != "None"){ //The start waypoint can in some cases be "None" - but the end waypoint cannot.
			startWp = std::stoi(waypointsInEdge.front());
		}
		endWp = std::stoi(waypointsInEdge.back());
	}
	catch(std::invalid_argument& e) //or catch(...) to catch all exceptions
	{
		std::cout << "String to int exception for argument " << edgeName << ". This will NOT be considered as a mandatory part-connecting edge." << std::endl;
	}
	if(startWp>=boxes->size()||endWp>=boxes->size()){
		return true;
	}
	else{
		return false;
	}
}

int PlanCoverageEstimator::updateMemoisedEdges(
		const std::vector<std::vector<std::vector<double> > >& allSolutions) {
	//std::cout << "population is: " << std::endl;
	//Finding all edges in the current population.
	std::set<std::string> allEdgesInPopulation;
	for (std::vector<std::vector<std::vector<double> > >::const_iterator popItt =
			allSolutions.begin(); popItt != allSolutions.end(); popItt++) {
		//std::cout << "Next individual: ";
		std::vector<std::vector<double> > currentSolution = *popItt;
		std::string previousPlanPartName = "start";
		for (std::vector<std::vector<double> >::iterator planItt =
				currentSolution.begin(); planItt < currentSolution.end();
				planItt++) {
			std::vector<double> nextStep = *planItt;
			std::string currentPlanPartName = vectorToString(nextStep,
					nextStep.size());
			std::string memoizationIndex = previousPlanPartName + "-"
					+ currentPlanPartName; //The string we use to store and look up the current edge.
			allEdgesInPopulation.insert(memoizationIndex);

			//std::cout << memoizationIndex << " - ";
			std::vector<double> prevStep = nextStep;
			previousPlanPartName = vectorToString(prevStep, 1);
		}
	}
	//std::cout<<std::endl;
	std::set<std::string> edgesToRemove;
	//Removing any memoized edges not in the population.
	for (std::map<std::string, boost::dynamic_bitset<> >::iterator memEdges2 =
			memoisedEdgesBitset->begin();
			memEdges2 != memoisedEdgesBitset->end(); memEdges2++) {
		std::string edgeName = memEdges2->first;
		if(edgeConnectsMandatoryPart(edgeName)){
			continue;//Avoiding deleting edges connecting to mandatory plan parts - since they are highly likely to be useful later in the run.
		}
		if (allEdgesInPopulation.find(edgeName) == allEdgesInPopulation.end()) { //Find in set has logarithmic complexity.
			edgesToRemove.insert(edgeName);
		}
	}

	std::cout << "Before deletion, had " << memoisedEdgesBitset->size() << " memoized edges " << std::endl;
	for (std::set<std::string>::iterator deletedEdge = edgesToRemove.begin();
			deletedEdge != edgesToRemove.end(); deletedEdge++) {
		memoisedEdgesBitset->erase(*deletedEdge);
	}
	std::cout << "Deleted edges. Remaining edges are " << memoisedEdgesBitset->size() << std::endl;

	return memoisedEdgesBitset->size();
}

std::vector<std::vector<std::vector<double> > > PlanCoverageEstimator::getSimplePlans() const {
	PlanInterpreterBoxOrder* interpreter;
	if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
		interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	} else {
		throw std::domain_error(
				"ERROR! Local search is only supported for a  'box-order' representation of plans");
	}
	return interpreter->generateOrGetCompleteCirclingPlans();
}

void PlanCoverageEstimator::interpretAndExportPlan(
		const std::vector<std::vector<double> >& plan,
		std::vector<std::vector<double> >& plannedPositions,
		std::vector<std::vector<double> >& plannedAngles) const{
	osg::ref_ptr<osg::Vec3dArray> osgPlanPos = new osg::Vec3dArray();
	osg::ref_ptr<osg::Vec3dArray> osgPlanOrientations = new osg::Vec3dArray();
	planInterpreter->InterpretPlan(plan, *osgPlanPos, *osgPlanOrientations);

	plannedPositions = convertOsgVec3dArrayToVector(*osgPlanPos);
	plannedAngles = convertOsgVec3dArrayToVector(*osgPlanOrientations);
}

int PlanCoverageEstimator::getNumMandatoryLoops() const {
	PlanInterpreterBoxOrder* interpreter;
	if (dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter) != nullptr) {
		interpreter = dynamic_cast<PlanInterpreterBoxOrder*>(planInterpreter);
	} else {
		//TODO: Catch this error somewhere.
		throw std::domain_error(
				"ERROR! Mandatory loops are only supported for a  'box-order' representation of plans");
	}
	return interpreter->getNumMandatorySegments();
}

	double PlanCoverageEstimator::getMaxAllowedEnergy() const {
		return energyEvaluator->getMaxAllowedEnergy();
	}

} /* namespace evolutionary_inspection_plan_evaluation */
