%module eval_func
%include "std_vector.i"
%include "std_string.i"
%include typemaps.i

%{
#define SWIG_FILE_WITH_INIT
#include "/home/kai/workspace/bir/bir_workspace/Coverage_Path_Planning/MOEA_Coverage/src/PlanCoverageEstimator.h"
%}


namespace std {
%template(Line)  vector < double >;
%template(Array) vector < vector < double> >;
%template() vector < vector < vector < double> > >;
%template(StringVector) vector < string >;
}

namespace geometric_utils {
std::vector<std::vector<double> > viewMatrixSelector(std::string sceneFileName);

class PlanCoverageEstimator{
public:
PlanCoverageEstimator(const std::string& sceneFileName, const std::vector<double>& sensorSpecs, const std::string& interpretationType, bool postProcessing = false,const std::vector<double>* startLocation = NULL, bool planLoopsAround = false,  bool printerFriendly = true, const std::vector<std::string>& mandatoryPlanPartsFiles = std::vector<std::string>());//The argument returnedDrawable is not possible to create in Python, as it is of an OSG type. However, I believe we will never need to create it in
//Python, so we can just ignore that optional argument inside Python for now.
std::vector<double> evaluatePlan(const std::vector<std::vector<double> >& plan, bool memoization, bool shouldPlot, double strictEnergyLimit = -1);#, osg::ref_ptr<osg::Group> returnedDrawable = NULL
int getNumberOfBoxes() const;
std::vector<std::vector<double> > LocalSearch(const std::vector<std::vector<double> >& plan, double localSearchLimit = 1, int startNeighbor = 0);
int updateMemoisedEdges(const std::vector<std::vector<std::vector<double> > >& allSolutions);
std::vector<std::vector<std::vector<double> > > getSimplePlans() const;
void storePlanImage(const std::vector<std::vector<double> >& plan, const std::vector<std::vector<double> >& viewMatrix, const std::string& storagePath);
double getMaxAllowedEnergy() const;
//This is how SWIG turns a C++ return by reference into a Python multiple-argument return. Called in python like: [a, b] = interpretAndExportPlan(plan, [], [])
void interpretAndExportPlan(const std::vector<std::vector<double> >& plan, std::vector<std::vector<double> > &INOUT, std::vector<std::vector<double> > &INOUT);

int getNumMandatoryLoops();
};
}
